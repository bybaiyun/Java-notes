# Java-notes
---

>> 王道Java学习记录

* CMD/Powershell乱码

切换字符集：chcp 65001(UTF-8)、chcp 936(GBK)

* 从C盘切换到D盘
> D: 或者 cd /D D:

* 网络相关
网关地址就是路由器的IP地址，静态IP需要设置默认网关、DNS、子网掩码等等，动态IP只需要路由器DHCP自动分配IP地址

## 位运算

>> 首先要强调一点：计算机处理数据都是以**补码**的形式进行计算

### 1. 取反 ~
>> ~ 把补码中的 0 和 1 全部取反（0 变为 1，1 变为 0），取反时每一位都参与运算，包括符号位

* 计算：~9 和 ~-9
```
~9 的计算步骤：
原码：0 1001
补码：0 1001
按位取反：1 0110
原码：1 1010
 = -10

 ~-9 的计算步骤：
原码：1 1001
补码：1 0111
按位取反：0 1000
原码：0 1000
 = 8
```

### 2. 移位 >>

右移时需要在左侧用**符号位**（正数为 0，负数为 1）补齐

1. 负数的右移

>> 解释：`-5 >> 2 == -2`

```
-5
原码 1000 …… 0101
反码 1111 …… 1010 负数的反码是保留符号位不变原码取反
补码 1111 …… 1011 补码是反码加1
>>2 (负数右移高位补1)
补码 1111 …… 1110
反码 1111 …… 1101 补码转反码减1
原码 1000 … 0010 负数反码转原码保留符号位不变取反
= -2
```

2. 正数的右移
>> 解释：`5 >> 2 == 1`

```
+5
原码 0000 …… 0101
补码 0000 …… 0101
/>>2（正数右移高位补0）
补码 0000 …… 0001
原码 0000 …… 0001
= 1
```
3. 左移

左移时在后面补 0。值得注意的是，对于 int 型来说左移 32 位等于原来的数，移位的位数 >= 32 时会先取余再进行移位，比如左移 34 位等于左移 2（34 % 32）位。

相对于右移，左移还需要考虑**溢出**的问题。

### 异或 ^
(1). 异或的性质

异或满足以下四个性质：
```
归零率：a ^ a = 0
恒等率：a ^ 0 = a
交换律：a ^ b = b ^ a
结合律：a ^ (b ^ c) = (a ^ b) ^ c
```

由异或的归零率和结合律可以推出异或的另一条性质：
>> 自反： a ^ b ^ b = a ^ 0 = a

(2). 异或的应用

* 快速比较两个值是否相等（归零率）

利用`a ^ b == 0`可以快速判断 a 和 b 是否相等

* 交换两个变量的值

```
a = a ^ b;
b = a ^ b;         //a ^ b ^ b = a ^ 0 = a
a = a ^ b;         //a ^ b ^ a = b ^ a ^ a = b
```

* 最常出现的面试题：一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字；

比如，从 `{1, 2, 3, 4, 5, 3, 2, 4, 5}` 中找出单个的数字： 1

首先，我们来看一个简单的例子。因为异或满足交换律、结合律和归零率，所以假设有数组：A B C B C D A 使用异或：

```
A ^ B ^ C ^ B ^ C ^ D ^ A
= A ^ A ^ B ^ B ^ C ^ C ^ D
= 0 ^ 0 ^ 0 ^ D
= 0 ^ D
= D
```
这样我们就找出了只出现一次的元素：D

**代码**

```C
//空间复杂度为O(1)，时间复杂度为O(n)
int singlenumber(int array[], int length){
    if(length <= 0)
        return -1;
    if(length == 1)
        return array[1];
    int result = 0; // a ^ 0 = a
    for(int index = 0; index < length; index++){
        result = result ^ array[index];
    }
    return result;
}
```

## 模运算

* 求 `a % b` 的步骤：
```
1.求整数商：c = a / b;
2.计算模或者余数：r = a - c * b;
```
如果ab都为正数，则取模与取余得到的商相同
对于被除数为负数的取模运算结果取决于具体的编程语言，一般分为两种类型：
1.`floor除法`，就是商采用`floor法`取整，因而也叫趋负无穷截尾。目前采用这种方式的编程语言有`python`等。

例如：`-7 % 3` 中，商向下取整得 -3，所以模就为 2.

2.`truncate 除法`，就是商尽可能的靠近 0，因此又称截断取整。目前采用这种的方式的编程语言有`C`、`java`还有`js`等。例如`-7 % 3`,靠 0 取整得 -2，所以模就为 -1.
>> 巧记：`floor法`的话，模的符号和除数相同；而`truncate法`的话，模的符号和被除数相同。
